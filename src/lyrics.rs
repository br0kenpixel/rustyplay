use crate::lyrics_parse::{Lyrics, LyricsEntry};
use std::path::PathBuf;
use std::time::Duration;

/// Defines the amount of lines that can be displayed by the TUI.
///
/// ## Note
/// The actual amount of [`LyricsLine`](LyricsLine)s stored in
/// [`LyricsBank`](LyricsBank) is [`LYRICS_BANK_SIZE`](LYRICS_BANK_SIZE) + 1.
/// The extra one is used to prevent the TUI from switching to another bank
/// too early.
pub const LYRICS_BANK_SIZE: usize = 4;

/// Represents a small set of lines from the lyrics.  
#[derive(Debug, Clone)]
pub struct LyricsBank {
    /// Internal stack  
    /// The length of this vector should be no more than [`LYRICS_BANK_SIZE`](LYRICS_BANK_SIZE) + 1
    pub lines: Vec<LyricsEntry>,
}

/// This structure represents a lyrics file.
#[derive(Debug)]
pub struct LyricsProcessor {
    /// Lines of lyrics.
    lines: Vec<LyricsEntry>,
}

impl LyricsProcessor {
    /// Loads a lyrics file from a given path.
    /// The lyrics file is a JSON file who's contents can be generated by:
    /// - [`akashrchandran/spotify-lyrics-api`](https://github.com/akashrchandran/spotify-lyrics-api)
    /// - [`br0kenpixel/spotify-lyrics-api-rust`](https://github.com/br0kenpixel/spotify-lyrics-api-rust)  
    /// `LRC`'s are not supported and likely never will be.
    pub fn load_file(file: String) -> Result<Self, String> {
        let mut lyrics = Lyrics::parse_file(&PathBuf::from(file))
            .map_err(|e| format!("File parse error: {e}"))?;
        lyrics.fix_end_times();

        Ok(Self {
            lines: lyrics.lines,
        })
    }

    /// Gets the (next) [`LyricsBank`](LyricsBank).
    /// If `prev_bank` is `None`, the returned [`LyricsBank`](LyricsBank)
    /// will contain the first [`LYRICS_BANK_SIZE`](LYRICS_BANK_SIZE) + 1 lines
    /// from the lyrics.
    ///
    /// ## Panics
    /// This function may panic if `prev_bank` is a malformed [`LyricsBank`](LyricsBank).
    pub fn get_bank(&self, prev_bank: Option<LyricsBank>) -> LyricsBank {
        if prev_bank.is_none() {
            return LyricsBank {
                lines: self
                    .lines
                    .iter()
                    .take(LYRICS_BANK_SIZE + 1)
                    .cloned()
                    .collect(),
            };
        }

        let prev_bank = prev_bank.unwrap();
        let end = self
            .lines
            .iter()
            .position(|entry| prev_bank.lines.last().unwrap().startTimeMs == entry.startTimeMs)
            .unwrap();

        let mut result = Vec::new();
        for i in end..=(end + LYRICS_BANK_SIZE) {
            match self.lines.get(i) {
                None => break,
                Some(val) => result.push(val.clone()),
            }
        }

        LyricsBank { lines: result }
    }
}

impl LyricsBank {
    /// Alias to the [`lines`](LyricsBank::lines) attribute's [`last()`](Iterator::last).
    ///
    /// ## Panics
    /// This function will panic if the aliased function returns `None`.
    pub fn last(&self) -> &LyricsEntry {
        self.lines.last().unwrap()
    }

    /// Alias to the [`lines`](LyricsBank::lines) attribute's [`len()`](Vec::len).
    pub fn len(&self) -> usize {
        self.lines.len()
    }

    /// Get the index of a line in [`LyricsBank`](LyricsBank) which
    /// should be highlighted according to the given playtime.
    ///
    /// ## Notes
    /// Returns `None` if no line should be highlighted at the given playtime.
    pub fn get_active(&self, time: Duration) -> Option<usize> {
        let potential = self
            .lines
            .iter()
            .take(LYRICS_BANK_SIZE)
            .rposition(|entry| time >= entry.startTimeMs.get());
        if let Some(index) = potential {
            let entry = &self.lines[index];

            if entry.is_endtime_valid() && time >= entry.endTimeMs.get() {
                return None;
            }
            return Some(index);
        }
        None
    }

    /// Returns whether the bank should no longer be used and the
    /// next one should be requested using [`get_bank()`](LyricsProcessor::get_bank).
    pub fn is_expired(&self, playtime: Duration) -> bool {
        playtime >= self.last().startTimeMs.get()
    }

    /// Returns whether this bank is the last or the next one can be requested
    /// using [`get_bank()`](LyricsProcessor::get_bank).
    ///
    /// ## Notes
    /// [`get_bank()`](LyricsProcessor::get_bank) should not be called if
    /// this function returns `false`.
    pub fn next_available(&self) -> bool {
        self.len() > LYRICS_BANK_SIZE
    }
}
