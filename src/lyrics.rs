use std::fs;
use std::str;
use std::path::Path;
use std::time::{Duration};
use json::*;
use itertools::Itertools;

/// Represents a line of lyrics.
#[derive(Debug, Clone)]
struct LyricsLine {
    /// Time at which the line should be displayed.
    time: Duration,
    /// Time at which the line should be hidden.
    end_time: Option<Duration>,
    /// Text of the line.
    text: String
}

/// This structure represents a lyrics file.
#[derive(Debug)]
pub struct LyricsProcessor {
    /// Lines of lyrics.
    lines: Vec<LyricsLine>
}

impl LyricsProcessor {
    /// Loads a lyrics file from a given path.
    /// The lyrics file is a JSON file who's contents can be generated by:
    /// - [`akashrchandran/spotify-lyrics-api`](https://github.com/akashrchandran/spotify-lyrics-api)
    /// - [`br0kenpixel/spotify-lyrics-api-rust`](https://github.com/br0kenpixel/spotify-lyrics-api-rust)  
    /// `LRC`'s are not supported and likely never will be.
    pub fn load_file(file: String) -> Result<LyricsProcessor> {
        let content = fs::read(Path::new(&file)).expect("Cannot open lyrics file");
        let content = str::from_utf8(&content).unwrap();

        let json_content = match parse(content) {
            Ok(json) => json,
            Err(e) => return Err(e)
        };

        assert!(json_content["error"] == false);
        let json_content = json_content["lines"].clone();

        Ok(LyricsProcessor {
            lines: LyricsProcessor::parse_lines(json_content)
        })
    }

    /// Gets the line of lyrics that should be displayed at the given time.
    pub fn get_line(&self, time: Duration) -> Option<String> {
        for (first, second) in self.lines.iter().tuple_windows() {
            if time >= first.time && time <= second.time {
                if !first.end_time.is_none() && time >= first.end_time.unwrap() {
                    return None;
                }
                return Some(first.text.clone());
            }
        }

        None
    }

    /// Parses the lines of lyrics from a JSON object.
    fn parse_lines(raw_lines: JsonValue) -> Vec<LyricsLine> {
        let mut result: Vec<LyricsLine> = Vec::new();

        for index in 0..raw_lines.len() {
            let item = &raw_lines[index];

            let start_ms = &item["startTimeMs"].as_str().unwrap();
            let start_ms = start_ms.parse::<u64>().unwrap();

            let words: String = item["words"].as_str().unwrap().to_owned();

            if words == "â™ª" {
                match result.get_mut(index - 1) {
                    Some(line) => {
                        line.end_time = Some(Duration::from_millis(start_ms));
                    },
                    None => ()
                }
                continue;
            }

            result.push(LyricsLine {
                time: Duration::from_millis(start_ms),
                text: words,
                end_time: None
            });
        }

        result
    }
}