use std::fs;
use std::path::Path;
use std::time::{Duration};
use json::*;

/// Represents a line of lyrics.
#[derive(Debug, Clone)]
struct LyricsLine {
    /// Time at which the line should be displayed.
    time: Duration,
    /// Time at which the line should be hidden.
    end_time: Option<Duration>,
    /// Text of the line.
    text: String
}

/// This structure represents a lyrics file.
#[derive(Debug)]
pub struct LyricsProcessor {
    /// Lines of lyrics.
    lines: Vec<LyricsLine>
}

impl LyricsProcessor {
    /// Loads a lyrics file from a given path.
    /// The lyrics file is a JSON file who's contents can be generated by:
    /// - [`akashrchandran/spotify-lyrics-api`](https://github.com/akashrchandran/spotify-lyrics-api)
    /// - [`br0kenpixel/spotify-lyrics-api-rust`](https://github.com/br0kenpixel/spotify-lyrics-api-rust)  
    /// `LRC`'s are not supported and likely never will be.
    pub fn load_file(file: String) -> LyricsProcessor {
        let content = fs::read(Path::new(&file)).expect("Cannot open LRC file");
        let content = String::from_utf8(content).unwrap();

        let json_content = match parse(content.as_str()) {
            Ok(json) => json,
            Err(e) => panic!("JSON parsing failed: {e}")
        };

        assert!(json_content["error"] == false);
        let json_content = json_content["lines"].clone();

        LyricsProcessor {
            lines: LyricsProcessor::parse_lines(json_content)
        }
    }

    /// Alias for [`LyricsProcessor::load_file()`](Self::load_file()) that returns `None` if the file does not exist.
    pub fn try_load_file(file: String) -> Option<LyricsProcessor> {
        if !Path::new(&file).exists() {
            return None;
        }
        Some(LyricsProcessor::load_file(file))
    }

    /// Gets the line of lyrics that should be displayed at the given time.
    pub fn get_line(&self, time: Duration) -> Option<String> {
        for (i, j) in (0..self.lines.len()).zip(1..self.lines.len()) {
            let first = &self.lines[i];
            let second = &self.lines[j];

            if time >= first.time && time <= second.time {
                if !first.end_time.is_none() && time >= first.end_time.unwrap() {
                    return None;
                }
                return Some(first.text.clone());
            }
        }

        None
    }

    /// Parses the lines of lyrics from a JSON object.
    fn parse_lines(raw_lines: JsonValue) -> Vec<LyricsLine> {
        let mut result: Vec<LyricsLine> = Vec::new();

        for index in 0..raw_lines.len() {
            let item = &raw_lines[index];

            let start_ms = &item["startTimeMs"].as_str().unwrap();
            let start_ms = start_ms.parse::<u64>().unwrap();

            let words: &str = &item["words"].as_str().unwrap();
            let words: String = String::from(words);

            result.push(LyricsLine {
                time: Duration::from_millis(start_ms),
                text: words,
                end_time: None
            });
        }

        let mut index = 0;
        while index < result.len() {
            let current = result[index].clone();
            if current.text == "â™ª" {
                let mut previous = result.get_mut(index - 1).unwrap();
                previous.end_time = Some(current.time);
                result.remove(index);
            } else {
                index += 1;
            }
        }

        result
    }
}